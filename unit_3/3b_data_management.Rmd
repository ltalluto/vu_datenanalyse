---
title: "Data Management"
author: "Matthew Talluto"
date: "23.02.2022"
output:
  slidy_presentation:
    theme: cerulean
    toc_depth: 2
    css:  ../assets/rmd_style.css
  beamer_presentation: default
---


```{r setup, include=FALSE, results = "hide"}
# knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(fig.width=7, fig.height=7, collapse = TRUE, comment = "##", dev="png", error=TRUE)
library(RColorBrewer)
cols = brewer.pal(8, "Set1")

```

## Filtering

> 1. The dataset is fairly large ;-), i.e. *exploration* could take you a while. Therefore start with filtering a subset of intermediate stoichiometry in the medium (either level 5 or 50).

```{r}
mic = read.table("../unit_2/data/MicrobesStoichiometry.txt", header = TRUE)
s1 = subset(mic, NP == 50 | NP == 5)
s2 = mic[mic$NP == 50 | mic$NP == 5,]

rows = which(mic$NP == 50 | mic$NP == 5)
s3 = mic[rows,]

identical(s1, s2)
identical(s1, s3)
```

## Combining a subset of variables

> 2. The dataset is multivariate, we are mainly interested in aabundance of *nucleic acids*. Could all the nucleic acid Raman signatures be considered to inform about the same property *nucleic acid abundance*? If so, average the signatures to create a new *metavariable*. Consider using `scale` before averaging. 

```{r}
(na_cols = grep("na_", colnames(mic)))
na_scaled = scale(mic[,na_cols])
head(na_scaled)
mic$na_mean_sc = rowMeans(na_scaled)
```


## Aggregation

> 3. Measurements of individual bacterial cells are replicates **within** each bottle. The experimental design in fact requires a mixed model analysis that accounts for the dependency of measurements within each bottle. As an alternative, the dataset could be collapsed to the level it is actually independently replicated, i.e. the bottle. This could be done by computing means per bottle, forming a new dataset with only 1 *average* bacterium per bottle. It may be worthwhile to explore distribution of measurements within a bottle - maybe a different measure should be used to get an average *location*. Not collapsing the dataset to bottle means would mean to use a **pseudoreplicated** dataset.


```{r, fig.height = 18, fig.width=18}
## use tapply with a custom anonymous function to make a histogram with density curve for each bottle
## there are 86, so we need to do something to make it manageable
par(mfrow=c(8,11), mar=c(0.1,0.1,0.1,0.1))

## an anonymous function!
invis <- tapply(mic$na_mean_sc, mic$bottle, function(x) {
  hist(x, freq = FALSE, main="", bty='n', xaxt='n', yaxt='n')
  lines(density(x))
})
```


## Aggregation

> 3. Measurements of individual bacterial cells are replicates **within** each bottle. The experimental design in fact requires a mixed model analysis that accounts for the dependency of measurements within each bottle. As an alternative, the dataset could be collapsed to the level it is actually independently replicated, i.e. the bottle. This could be done by computing means per bottle, forming a new dataset with only 1 *average* bacterium per bottle. It may be worthwhile to explore distribution of measurements within a bottle - maybe a different measure should be used to get an average *location*. Not collapsing the dataset to bottle means would mean to use a **pseudoreplicated** dataset.


```{r}
mic_agg = aggregate(. ~ bottle + species + growthphase + NP, data = mic[, -c(2, 6)], FUN = median) #any fun you like

```



## Reshaping

> The climate data are presented in a "tall" format (common for many public data products). We need these to be "wide" (with one variable per column).

```{r}
clim = read.csv("data/tree_clim.csv")
head(clim)
library(reshape2)
clim_wide = dcast(clim, plot_id+year_measured ~ variable)
head(clim_wide)

## go back to tall
clim_tall = melt(clim_wide, id.vars = c("plot_id", "year_measured"))
head(clim_tall)
```



## Merging

> After the climate data are reshaped, it is necessary to extract the relevant rows (there is more climate data than tree data) and match them to the correct rows in the tree data. It might also be nice to get proper species names into the trees table

```{r}
(species = read.csv("data/tree_species.csv"))
trees = read.csv("data/trees.csv")
head(trees)

trees = merge(trees, species, by.x = "species_code", by.y = "spName")
trees = merge(trees, clim_wide, by.x = c("plot", "year"), 
              by.y= c("plot_id", "year_measured"))

```

